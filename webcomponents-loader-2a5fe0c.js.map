{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./node_modules/@webcomponents/webcomponentsjs/webcomponents-loader.js"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","r","value","n","__esModule","object","property","prototype","hasOwnProperty","p","s","flushFn","polyfillsLoaded","whenLoadedFns","allowUpgrades","fireEvent","window","WebComponents","ready","document","dispatchEvent","CustomEvent","bubbles","batchCustomElements","customElements","polyfillWrapFlushCallback","flushCallback","HTMLTemplateElement","bootstrap","runWhenLoadedFns","then","Promise","all","map","fn","Function","length","catch","err","console","error","_batchCustomElements","waitFor","waitFn","push","polyfills","Element","ShadyDOM","force","forcePolyfill","needsTemplate","t","createElement","content","cloneNode","DocumentFragment","t2","appendChild","clone","childNodes","firstChild","Array","from","URL","Symbol","script","querySelector","newScript","replacement","join","url","src","replace","readyState","setAttribute","write","outerHTML","addEventListener","Error","head","removeEventListener"],"mappings":"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","file":"webcomponents-loader-2a5fe0c.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 4);\n","/**\n * @license\n * Copyright (c) 2018 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n */\n\n(function() {\n  'use strict';\n\n  /**\n   * Basic flow of the loader process\n   *\n   * There are 4 flows the loader can take when booting up\n   *\n   * - Synchronous script, no polyfills needed\n   *   - wait for `DOMContentLoaded`\n   *   - run callbacks passed to `waitFor`\n   *   - fire WCR event\n   *\n   * - Synchronous script, polyfills needed\n   *   - document.write the polyfill bundle\n   *   - wait on the `load` event of the bundle to batch Custom Element upgrades\n   *   - wait for `DOMContentLoaded`\n   *   - run callbacks passed to `waitFor`\n   *   - fire WCR event\n   *\n   * - Asynchronous script, no polyfills needed\n   *   - fire WCR event, as there could not be any callbacks passed to `waitFor`\n   *\n   * - Asynchronous script, polyfills needed\n   *   - Append the polyfill bundle script\n   *   - wait for `load` event of the bundle\n   *   - batch Custom Element Upgrades\n   *   - run callbacks pass to `waitFor`\n   *   - fire WCR event\n   */\n\n  var polyfillsLoaded = false;\n  var whenLoadedFns = [];\n  var allowUpgrades = false;\n  var flushFn;\n\n  function fireEvent() {\n    window.WebComponents.ready = true;\n    document.dispatchEvent(new CustomEvent('WebComponentsReady', { bubbles: true }));\n  }\n\n  function batchCustomElements() {\n    if (window.customElements && customElements.polyfillWrapFlushCallback) {\n      customElements.polyfillWrapFlushCallback(function (flushCallback) {\n        flushFn = flushCallback;\n        if (allowUpgrades) {\n          flushFn();\n        }\n      });\n    }\n  }\n\n  function asyncReady() {\n    batchCustomElements();\n    ready();\n  }\n\n  function ready() {\n    // bootstrap <template> elements before custom elements\n    if (window.HTMLTemplateElement && HTMLTemplateElement.bootstrap) {\n      HTMLTemplateElement.bootstrap(window.document);\n    }\n    polyfillsLoaded = true;\n    runWhenLoadedFns().then(fireEvent);\n  }\n\n  function runWhenLoadedFns() {\n    allowUpgrades = false;\n    var done = function() {\n      allowUpgrades = true;\n      whenLoadedFns.length = 0;\n      flushFn && flushFn();\n    };\n    return Promise.all(whenLoadedFns.map(function(fn) {\n      return fn instanceof Function ? fn() : fn;\n    })).then(function() {\n      done();\n    }).catch(function(err) {\n      console.error(err);\n    });\n  }\n\n  window.WebComponents = window.WebComponents || {\n    ready: false,\n    _batchCustomElements: batchCustomElements,\n    waitFor: function(waitFn) {\n      if (!waitFn) {\n        return;\n      }\n      whenLoadedFns.push(waitFn);\n      if (polyfillsLoaded) {\n        runWhenLoadedFns();\n      }\n    }\n  };\n\n  var name = 'webcomponents-loader.js';\n  // Feature detect which polyfill needs to be imported.\n  var polyfills = [];\n  if (!('attachShadow' in Element.prototype && 'getRootNode' in Element.prototype) ||\n    (window.ShadyDOM && window.ShadyDOM.force)) {\n    polyfills.push('sd');\n  }\n  if (!window.customElements || window.customElements.forcePolyfill) {\n    polyfills.push('ce');\n  }\n\n  var needsTemplate = (function() {\n    // no real <template> because no `content` property (IE and older browsers)\n    var t = document.createElement('template');\n    if (!('content' in t)) {\n      return true;\n    }\n    // broken doc fragment (older Edge)\n    if (!(t.content.cloneNode() instanceof DocumentFragment)) {\n      return true;\n    }\n    // broken <template> cloning (Edge up to at least version 17)\n    var t2 = document.createElement('template');\n    t2.content.appendChild(document.createElement('div'));\n    t.content.appendChild(t2);\n    var clone = t.cloneNode(true);\n    return (clone.content.childNodes.length === 0 ||\n        clone.content.firstChild.content.childNodes.length === 0);\n  })();\n\n  // NOTE: any browser that does not have template or ES6 features\n  // must load the full suite of polyfills.\n  if (!window.Promise || !Array.from || !window.URL || !window.Symbol || needsTemplate) {\n    polyfills = ['sd-ce-pf'];\n  }\n\n  if (polyfills.length) {\n    var script = document.querySelector('script[src*=\"' + name +'\"]');\n    var newScript = document.createElement('script');\n    // Load it from the right place.\n    var replacement = 'bundles/webcomponents-' + polyfills.join('-') + '.js';\n    var url = script.src.replace(name, replacement);\n    newScript.src = url;\n    // if readyState is 'loading', this script is synchronous\n    if (document.readyState === 'loading') {\n      // make sure custom elements are batched whenever parser gets to the injected script\n      newScript.setAttribute('onload', 'window.WebComponents._batchCustomElements()');\n      document.write(newScript.outerHTML);\n      document.addEventListener('DOMContentLoaded', ready);\n    } else {\n      newScript.addEventListener('load', function () {\n        asyncReady();\n      });\n      newScript.addEventListener('error', function () {\n        throw new Error('Could not load polyfill bundle' + url);\n      });\n      document.head.appendChild(newScript);\n    }\n  } else {\n    polyfillsLoaded = true;\n    if (document.readyState === 'complete') {\n      fireEvent()\n    } else {\n      // this script may come between DCL and load, so listen for both, and cancel load listener if DCL fires\n      window.addEventListener('load', ready);\n      window.addEventListener('DOMContentLoaded', function() {\n        window.removeEventListener('load', ready);\n        ready();\n      })\n    }\n  }\n})();\n"],"sourceRoot":""}